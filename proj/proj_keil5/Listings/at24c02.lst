C51 COMPILER V9.60.7.0   AT24C02                                                           12/08/2023 09:18:20 PAGE 1   


C51 COMPILER V9.60.7.0, COMPILATION OF MODULE AT24C02
OBJECT MODULE PLACED IN .\Objects\at24c02.obj
COMPILER INVOKED BY: E:\Keil C51\C51\BIN\C51.EXE ..\src\at24c02.c ROM(COMPACT) OPTIMIZE(8,SPEED) BROWSE INCDIR(..\includ
                    -e) DEBUG OBJECTEXTEND PRINT(.\Listings\at24c02.lst) OBJECT(.\Objects\at24c02.obj)

line level    source

   1          /**
   2           * ‰ΩúËÄÖÔºöÊùéÂÆóÈúñ Êó•ÊúüÔºö2023/12/04
   3           * CSDNÊòµÁß∞ÔºöLeisure_Ê∞¥‰∏≠È±º
   4           * CSDN: https://blog.csdn.net/Supine_0?type=blog
   5           * ----------------------------------------------
   6           * Ê≥®ÊÑè: 24c02ÁöÑÊìç‰ΩúÊòØÂü∫‰∫éI2CÊìç‰ΩúÁöÑ ÊâÄ‰ª•ÂØπÂÖ∂‰∏∫Âº∫‰æùËµñ 'i2c.h'
   7           */
   8          #include "i2c.h"
   9          
  10          #define AT24C02_NO_MULTI_PAGE_WRITE
  11          
  12          #ifndef uchar
  13          #define uchar unsigned char
  14          #endif
  15          
  16          #define PAGE_BIT 4
  17          #define PAGE_END 0x0f
  18          
  19          #define PAGE_BYTE 0x10 // ‰πüÁºìÂÜ≤Âô®Â≠óËäÇÊï∞
  20          
  21          // ËøûÁª≠ËØªÊó∂Â∫è
  22          bit At24c02_ReadData(uchar sla, uchar suba, uchar* dat, uchar num)
  23          {
  24   1          bit flg;
  25   1          uchar i;
  26   1          if (!num)
  27   1              return 1;
  28   1          I2C_Start();       // ÂêØÂä®I2CÊÄªÁ∫ø
  29   1          I2C_SendByte(sla); // ÂèëÈÄÅÂô®‰ª∂Âú∞ÂùÄÁ†Å
  30   1          if (flg = I2C_CheckAck())
  31   1          {
  32   2              I2C_SendByte(suba); // ÂèëÈÄÅÊúüÈó¥ÂçïÂÖÉÂú∞ÂùÄ
  33   2              if (flg = I2C_CheckAck())
  34   2              {
  35   3                  I2C_Start();           // ÈáçÊñ∞ÂêØÂä®I2CÊÄªÁ∫ø
  36   3                  I2C_SendByte(sla + 1); // ÂèëÈÄÅÂÜôÂô®‰ª∂Âú∞ÂùÄÁ†Å‰ø°Âè∑
  37   3                  if (flg = I2C_CheckAck())
  38   3                  {
  39   4                      for (i = num - 1; i; --i)
  40   4                      {
  41   5                          *dat = I2C_RecByte();
  42   5                          I2C_Ack();
  43   5                          ++dat;
  44   5                      }
  45   4                      *dat = I2C_RecByte();
  46   4                      I2C_NoAck();
  47   4                  }
  48   3              }
  49   2          }
  50   1          I2C_Stop();
  51   1          return flg;
  52   1      }
  53          
  54          // È°µÂÜôÂÖ•Êó∂Â∫è ÊúÄÂ§ö‰∏∫ È°µÂÜôÁºìÂÜ≤Âô®ÁöÑÂ§ßÂ∞è Â≠óËäÇ Ë∂ÖÂá∫‰ºöË¢´Âæ™ÁéØË¶ÜÁõñ ‰∏îÊ≠§ÂáΩÊï∞‰∏çÂ∏¶Âª
C51 COMPILER V9.60.7.0   AT24C02                                                           12/08/2023 09:18:20 PAGE 2   

             -∂Ëøü
  55          bit At24c02_WriteByte(uchar sla, uchar suba, uchar* dat, uchar num)
  56          {
  57   1          bit flg;
  58   1          uchar i;
  59   1          if (!num)
  60   1              return 1;
  61   1          I2C_Start();       // ÂêØÂä®I2CÊÄªÁ∫ø
  62   1          I2C_SendByte(sla); // ÂèëÈÄÅÂô®‰ª∂Âú∞ÂùÄÁ†Å
  63   1          if (flg = I2C_CheckAck())
  64   1          {
  65   2              I2C_SendByte(suba); // ÂèëÈÄÅÊúüÈó¥ÂçïÂÖÉÂú∞ÂùÄ
  66   2              if (flg = I2C_CheckAck())
  67   2              {
  68   3                  for (i = num; i; --i)
  69   3                  {
  70   4                      I2C_SendByte(*dat);
  71   4                      if (!(flg = I2C_CheckAck()))
  72   4                          break; // Êó†Â∫îÁ≠î
  73   4                      ++dat;
  74   4                  }
  75   3              }
  76   2          }
  77   1          I2C_Stop(); // ÂèëÈÄÅÁªìÊùü‰ø°Âè∑
  78   1          return flg;
  79   1      }
  80          
  81          #ifndef AT24C02_NO_MULTI_PAGE_WRITE
              
              void At24c02_Wait(void) // 12MHz 1000us
              {
                  uchar t = 164;
                  while (t--)
                      ;
                  for (t = 2; t; --t)
                      ;
              }
              
              bit At24c02_Check(uchar sla) // Ê£ÄÊü•ÊòØÂê¶ÂÜôÂÖ•ÂÆåÊàê
              {
                  uchar i = 16;
                  do // ÊØèÊØ´ÁßíÊ£ÄÊµã‰∏ÄÊ¨°Â¶ÇÊûú 16 Ê¨°Êú™Â∫îÁ≠îÂàôÊòØ‰∏∫ÈîôËØØ
                  {
                      At24c02_Wait();
                      I2C_Start();
                      I2C_SendByte(sla); // ÂèëÈÄÅÂô®‰ª∂Âú∞ÂùÄÁ†Å
                  } while (!I2C_CheckAck() && --i);
                  I2C_Stop();
                  return (i != 0);
              }
              
              // ËøûÁª≠È°µÂÜôÂÖ• Â∏¶Âª∂Ëøü(Á°Æ‰øùÂÜôÂÖ•ÂÆåÊàê)
              bit At24c02_WriteData(uchar sla, uchar suba, uchar* dat, uchar num)
              {
                  uchar begin, end, i;
                  if (!num)
                      return 1;
                  begin = suba >> PAGE_BIT;
                  end = (suba + (num - 1)) >> PAGE_BIT;
                  if (begin != end)
                  {
                      i = PAGE_END - (suba & PAGE_END) + 1;
C51 COMPILER V9.60.7.0   AT24C02                                                           12/08/2023 09:18:20 PAGE 3   

                      At24c02_WriteByte(sla, suba, dat, i);
                      suba += i;
                      dat += i;
                      ++begin;
                      if (!At24c02_Check(sla))
                          return 0;
                  }
                  while ((begin != end) && begin < PAGE_END)
                  {
                      At24c02_WriteByte(sla, suba, dat, PAGE_BYTE);
                      suba += PAGE_BYTE;
                      dat += PAGE_BYTE;
                      ++begin;
                      if (!At24c02_Check(sla))
                          return 0;
                  }
                  if (At24c02_WriteByte(
                          sla,
                          suba,
                          dat,
                          ((begin == end) ? ((num - i) & PAGE_END) : (PAGE_END))
                      ))
                      return At24c02_Check(sla);
                  else
                      return 0;
              }
              
              #endif
 144          
 145          /**
 146           * 2023/12/04
 147           * ÊúÄÂºÄÂßãÂ≠¶24c02Êàë‰ª•‰∏∫È°µÂÜôÂÖ•Êìç‰ΩúÊòØÂ≠òÂÇ®Á©∫Èó¥Ë¢´‰æãÂ¶Ç ÂàíÂàÜ‰∏∫‰∫Ü ÊØèÈ°µ16byte ÂÖ±16page
 148           * Êàë‰ª•‰∏∫ÊòØÂè™ËÉΩ‰ª•ÊØèÈ°µ‰∏∫Âçï‰ΩçËøõË°åÂ≠òÂÇ® ‰æãÂ¶Ç 0x03 ÂºÄÂßãÂ≠òÂÇ®Âà∞0x0f‰ºöËá™Âä®ËøîÂõûÂà∞0x00
 149           * ÂÆûÈôÖ‰∏äÊòØ‰∏ÄÊ¨°ÊúÄÂ§öËøûÁª≠ÂÜôÂÖ•16byte ‰∏ãÈù¢ÊúâÊàëÂÆûÁé∞ÁöÑ 'ÈîôËØØ' ÁöÑËøûÁª≠È°µÂÜôÂÖ•ÊñπÂºè
 150          ÂÆûÁé∞ÊñπÊ≥ïÂæàÊúâÂèÇËÄÉ‰ª∑ÂÄº
 151           * ÊïÖÊ≠§‰øùÁïô ÂèÇËßÅ24c02ÁöÑÊï∞ÊçÆÊâãÂÜåÂèØÁü• ÈúÄË¶ÅÈ°µÂÜôÂÖ•Êó∂Âõ†‰∏∫ÂèóÈôê‰∫é È°µÂÜôÁºìÂÜ≤Âô®ÁöÑÂ§ßÂ∞
             -è
 152          
 153           * 2023/12/05
 154           * ‰πãÂâçÂèàÈîô‰∫Ü ÊàëÊúÄÂºÄÂßãÁöÑÁêÜËß£Ê≤°Èîô 24c02ÂÜÖÂ≠òÂ∞±ÊòØË¢´ÂàÜ‰∏∫‰∫ÜÂ§öÈ°µ ÊØèÊ¨°ÂÜôÂÖ•Êó†Ê≥ïËá™Âä
             -®ÁøªÈ°µ
 155           * Êàë‰πãÂâçÁêÜËß£ÈîôËØØ ÂèÇËßÅ24c02ÁöÑÊï∞ÊçÆÊâãÂÜå:'ÂÜÖÂ≠òÂú∞ÂùÄ‰Ωé‰ΩçÂä†1 È´ò‰Ωç‰∏çÂèò'
 156          Â∞±ÊòØÊàë‰πãÂâçÁêÜËß£ÁöÑ
 157           * ÊâÄ‰ª•ÊàëÂ∞ÜÈáçÊñ∞ÂêØÁî®‰πãÂâçÁöÑÁÆóÊ≥ï Â∞ÜÈîôËØØÁöÑÁÆóÊ≥ïÊîæÂú®‰∏ãÊñπ‰ª•‰ΩúÂèÇËÄÉ
 158          
 159          
 160          
 161          bit At24c02_WriteData(uchar sla, uchar suba, uchar* dat, uchar num)
 162          {
 163              while (num > PAGE_BYTE) // ÊåâÈ°µÂÜôÂÖ•Êï∞ÊçÆ Âπ∂‰∏îÁ≠âÂæÖÂÜôÂÖ•ÊàêÂäüÂºÄÂßã‰∏ã‰∏ÄÈ°µÂÜôÂÖ•
 164              {
 165                  if (!At24c02_WriteByte(sla, suba, dat, PAGE_BYTE))
 166                      return 0;
 167                  suba += PAGE_BYTE;
 168                  dat += PAGE_BYTE;
 169                  num -= PAGE_BYTE;
 170                  if (!At24c02_Check(sla))
 171                      return 0;
 172              }
 173              if (At24c02_WriteByte(sla, suba, dat, num))
 174                  return At24c02_Check(sla);
 175              else
C51 COMPILER V9.60.7.0   AT24C02                                                           12/08/2023 09:18:20 PAGE 4   

 176                  return 0;
 177          }
 178          
 179          */


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    213    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----      14
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----       2
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
